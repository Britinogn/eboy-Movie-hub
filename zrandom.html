<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <template>
    <h1 class="text-2xl md:py-34 font-bold  py-28 text-center">Users Dashboard</h1>

    <!-- Loading -->
    <div v-if="loading" class="text-blue-500">Loading Users..........</div>

    <!-- users list -->

    <div v-else class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 ">

        <div v-for="movie in movies" 
            :key="movie.id"
            class="bg-white/60 shadow p-4 rounded-lg flex flex-col hover:bg-amber-200 items-center ">
        
            <img :src="movie.image" 
            alt="avatar" 
            class="w-20 h-20 rounded-full mb-3 "
            />

            <h2 class="text-lg font-semibold  ">{{ movie.title }} {{ movie.categories }} </h2>
            <p class="text-gray-500   ">{{ movie.link }}</p>

            
        </div>
    </div>
    
</template>
</body>
</html>

<script>
import { getUpcomingMovies } from "../services/api";

export default{
    data(){
        return{
            movies: [],
            loading: false,
        };
    },

    methods:{
        async fetchMovies() {
            this.loading = true;
            try {
                const res = await getUpcomingMovies();
                this.movies = res.data.movies.flatMap(group => group.list);;
                this.$toast.success('Movies fetched successfully!');
            
            } catch (error) {
                // console.error(err);
                console.log(error);
                this.$toast.error('Failed to fetch Movies.');
            
            } finally{
                this.loading = false;
            }
        },
      
    },

    mounted(){
        this.fetchMovies();
    },
};

</script>


<!--  -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progressive Coding Challenges</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 14px;
            font-weight: 600;
        }
        
        .btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
            transform: translateY(-2px);
        }
        
        .btn.active {
            background: rgba(255,255,255,0.4);
            border-color: rgba(255,255,255,0.6);
        }
        
        .challenge-card {
            background: rgba(255,255,255,0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .challenge-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
        }
        
        .difficulty {
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .easy { background: #e8f5e8; color: #2d5a2d; }
        .medium { background: #fff3cd; color: #856404; }
        .hard { background: #f8d7da; color: #721c24; }
        .expert { background: #d1ecf1; color: #0c5460; }
        
        .challenge-title {
            flex-grow: 1;
            font-size: 1.4rem;
            font-weight: 600;
            color: #333;
        }
        
        .challenge-description {
            margin-bottom: 20px;
            line-height: 1.6;
            color: #555;
        }
        
        .code-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .code-block {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            border: 2px solid #333;
        }
        
        .code-block h4 {
            color: #61dafb;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .code-block pre {
            color: #f8f8f2;
            font-size: 13px;
            line-height: 1.5;
            overflow-x: auto;
        }
        
        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .hint-btn { background: linear-gradient(45deg, #ff9a56, #ff6b6b); }
        .solution-btn { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        
        .hint, .solution {
            background: rgba(0,0,0,0.05);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            display: none;
        }
        
        .progress-bar {
            background: rgba(255,255,255,0.2);
            height: 8px;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .stats {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .code-section {
                grid-template-columns: 1fr;
            }
            
            .challenge-header {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Progressive Coding Challenges</h1>
            <p>Master Python & JavaScript with increasingly difficult problems</p>
        </div>
        
        <div class="stats">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p>Progress: <span id="progressText">0/8</span> challenges completed</p>
        </div>
        
        <div class="controls">
            <button class="btn active" onclick="showAll()">All Challenges</button>
            <button class="btn" onclick="filterDifficulty('medium')">Medium</button>
            <button class="btn" onclick="filterDifficulty('hard')">Hard</button>
            <button class="btn" onclick="filterDifficulty('expert')">Expert</button>
            <button class="btn" onclick="resetProgress()">Reset Progress</button>
        </div>
        
        <div id="challenges"></div>
    </div>

    <script>
        const challenges = [
            {
                id: 1,
                title: "Two Sum Variants",
                difficulty: "medium",
                description: "Find two numbers in an array that sum to a target. Return their indices. Handle edge cases like duplicates and no solution.",
                python: `def two_sum(nums, target):
                # Your solution here
                # Return indices [i, j] where nums[i] + nums[j] = target
                pass

                # Test cases:
                # two_sum([2, 7, 11, 15], 9) ‚Üí [0, 1]
                # two_sum([3, 2, 4], 6) ‚Üí [1, 2]
                # two_sum([3, 3], 6) ‚Üí [0, 1]`,
                            javascript: `function twoSum(nums, target) {
                // Your solution here
                // Return indices [i, j] where nums[i] + nums[j] = target
            }

            // Test cases:
            // twoSum([2, 7, 11, 15], 9); // [0, 1]
            // twoSum([3, 2, 4], 6); // [1, 2]
            // twoSum([3, 3], 6); // [0, 1]`,
                        hint: "Use a hash map to store numbers you've seen and their indices. For each number, check if (target - current_number) exists in your map.",
                        solution: {
                            python: `def two_sum(nums, target):
            seen = {}
            for i, num in enumerate(nums):
                complement = target - num
                if complement in seen:
                    return [seen[complement], i]
                seen[num] = i
            return []`,
                        javascript: `function twoSum(nums, target) {
            const seen = new Map();
            for (let i = 0; i < nums.length; i++) {
                const complement = target - nums[i];
                if (seen.has(complement)) {
                    return [seen.get(complement), i];
                }
                seen.set(nums[i], i);
            }
            return [];
        }`
                }
            },
            {
                id: 2,
                title: "Valid Parentheses with Types",
                difficulty: "medium",
                description: "Check if a string of brackets is valid. Handle (), [], and {}. Each opening bracket must be closed by the same type in correct order.",
                        python: `def is_valid_parentheses(s):
            # Your solution here
            # Return True if valid, False otherwise
            pass

        # Test cases:
        # is_valid_parentheses("()[]{}") ‚Üí True
        # is_valid_parentheses("([{}])") ‚Üí True
        # is_valid_parentheses("([)]") ‚Üí False`,
                        javascript: `function isValidParentheses(s) {
            // Your solution here
            // Return true if valid, false otherwise
        }

        // Test cases:
        // isValidParentheses("()[]{}"); // true
        // isValidParentheses("([{}])"); // true
        // isValidParentheses("([)]"); // false`,
                hint: "Use a stack! Push opening brackets, and when you see a closing bracket, check if it matches the most recent opening bracket.",
                solution: {
                    python: `def is_valid_parentheses(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            stack.append(char)
        
        return len(stack) == 0`,
                        javascript: `function isValidParentheses(s) {
        const stack = [];
        const mapping = {')': '(', '}': '{', ']': '['};
        
        for (let char of s) {
            if (char in mapping) {
                if (!stack.length || stack.pop() !== mapping[char]) {
                    return false;
                }
            } else {
                stack.push(char);
            }
        }
        
        return stack.length === 0;
    }`
                }
            },
            {
                id: 3,
                        title: "Longest Substring Without Repeating",
                        difficulty: "hard",
                        description: "Find the length of the longest substring without repeating characters. Use sliding window technique for optimal O(n) solution.",
                        python: `def length_longest_substring(s):
            # Your solution here
            # Return length of longest substring without repeating chars
            pass

        # Test cases:
        # length_longest_substring("abcabcbb") ‚Üí 3 ("abc")
        # length_longest_substring("bbbbb") ‚Üí 1 ("b")
        # length_longest_substring("pwwkew") ‚Üí 3 ("wke")`,
                        javascript: `function lengthLongestSubstring(s) {
            // Your solution here
            // Return length of longest substring without repeating chars
        }

        // Test cases:
        // lengthLongestSubstring("abcabcbb"); // 3 ("abc")
        // lengthLongestSubstring("bbbbb"); // 1 ("b") 
        // lengthLongestSubstring("pwwkew"); // 3 ("wke")`,
                        hint: "Use sliding window with two pointers. Keep a set/map of characters in current window. When you find a repeat, shrink window from left.",
                        solution: {
                            python: `def length_longest_substring(s):
            char_set = set()
            left = 0
            max_length = 0
            
            for right in range(len(s)):
                while s[right] in char_set:
                    char_set.remove(s[left])
                    left += 1
                
                char_set.add(s[right])
                max_length = max(max_length, right - left + 1)
            
            return max_length`,
                            javascript: `function lengthLongestSubstring(s) {
            const charSet = new Set();
            let left = 0;
            let maxLength = 0;
            
            for (let right = 0; right < s.length; right++) {
                while (charSet.has(s[right])) {
                    charSet.delete(s[left]);
                    left++;
                }
                
                charSet.add(s[right]);
                maxLength = Math.max(maxLength, right - left + 1);
            }
            
            return maxLength;
        }`
                        }
                    },
                    {
                        id: 4,
                        title: "Merge Intervals",
                        difficulty: "hard", 
                        description: "Given an array of intervals, merge overlapping ones. Sort first, then merge in one pass. Handle edge cases like empty input.",
                        python: `def merge_intervals(intervals):
            # Your solution here
            # Return list of merged intervals
            pass

        # Test cases:
        # merge_intervals([[1,3],[2,6],[8,10],[15,18]]) ‚Üí [[1,6],[8,10],[15,18]]
        # merge_intervals([[1,4],[4,5]]) ‚Üí [[1,5]]`,
                        javascript: `function mergeIntervals(intervals) {
            // Your solution here
            // Return array of merged intervals
        }

        // Test cases:
        // mergeIntervals([[1,3],[2,6],[8,10],[15,18]]); // [[1,6],[8,10],[15,18]]
        // mergeIntervals([[1,4],[4,5]]); // [[1,5]]`,
                        hint: "Sort intervals by start time. Iterate through sorted list, comparing each interval's start with previous interval's end.",
                        solution: {
                            python: `def merge_intervals(intervals):
            if not intervals:
                return []
            
            intervals.sort(key=lambda x: x[0])
            merged = [intervals[0]]
            
            for current in intervals[1:]:
                if current[0] <= merged[-1][1]:
                    merged[-1][1] = max(merged[-1][1], current[1])
                else:
                    merged.append(current)
            
            return merged`,
                            javascript: `function mergeIntervals(intervals) {
            if (!intervals.length) return [];
            
            intervals.sort((a, b) => a[0] - b[0]);
            const merged = [intervals[0]];
            
            for (let i = 1; i < intervals.length; i++) {
                const current = intervals[i];
                const last = merged[merged.length - 1];
                
                if (current[0] <= last[1]) {
                    last[1] = Math.max(last[1], current[1]);
                } else {
                    merged.push(current);
                }
            }
            
            return merged;
        }`
                        }
                    },
                    {
                        id: 5,
                        title: "Binary Tree Level Order Traversal",
                        difficulty: "hard",
                        description: "Return level-by-level traversal of binary tree as array of arrays. Use BFS with queue. Handle null nodes properly.",
                        python: `class TreeNode:
            def __init__(self, val=0, left=None, right=None):
                self.val = val
                self.left = left
                self.right = right

        def level_order(root):
            # Your solution here
            # Return [[level1], [level2], ...]
            pass

        # Test: root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))
        # Expected: [[3], [9, 20], [15, 7]]`,
                        javascript: `class TreeNode {
            constructor(val = 0, left = null, right = null) {
                this.val = val;
                this.left = left;
                this.right = right;
            }
        }

        function levelOrder(root) {
            // Your solution here
            // Return [[level1], [level2], ...]
        }

        // Test: root = new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7)));
        // Expected: [[3], [9, 20], [15, 7]]`,
                        hint: "Use BFS with a queue. Process all nodes at current level before moving to next. Track level size to know when to start new level array.",
                        solution: {
                            python: `from collections import deque

        def level_order(root):
            if not root:
                return []
            
            result = []
            queue = deque([root])
            
            while queue:
                level_size = len(queue)
                level = []
                
                for _ in range(level_size):
                    node = queue.popleft()
                    level.append(node.val)
                    
                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)
                
                result.append(level)
            
            return result`,
                            javascript: `function levelOrder(root) {
            if (!root) return [];
            
            const result = [];
            const queue = [root];
            
            while (queue.length) {
                const levelSize = queue.length;
                const level = [];
                
                for (let i = 0; i < levelSize; i++) {
                    const node = queue.shift();
                    level.push(node.val);
                    
                    if (node.left) queue.push(node.left);
                    if (node.right) queue.push(node.right);
                }
                
                result.push(level);
            }
            
            return result;
        }`
                        }
                    },
                    {
                        id: 6,
                        title: "LRU Cache Implementation",
                        difficulty: "expert",
                        description: "Implement Least Recently Used cache with O(1) get and put operations. Use doubly linked list + hash map. Handle capacity limits.",
                        python: `class LRUCache:
            def __init__(self, capacity):
                # Your implementation here
                pass
            
            def get(self, key):
                # Return value if exists, -1 otherwise
                # Move to most recently used
                pass
            
            def put(self, key, value):
                # Insert/update key-value pair
                # Evict LRU if at capacity
                pass

        # Test: cache = LRUCache(2)
        # cache.put(1, 1), cache.put(2, 2), cache.get(1) ‚Üí 1
        # cache.put(3, 3), cache.get(2) ‚Üí -1`,
                        javascript: `class LRUCache {
            constructor(capacity) {
                // Your implementation here
            }
            
            get(key) {
                // Return value if exists, -1 otherwise
                // Move to most recently used
            }
            
            put(key, value) {
                // Insert/update key-value pair  
                // Evict LRU if at capacity
            }
        }

        // Test: cache = new LRUCache(2);
        // cache.put(1, 1); cache.put(2, 2); cache.get(1); // 1
        // cache.put(3, 3); cache.get(2); // -1`,
                        hint: "Use hash map for O(1) access and doubly linked list for O(1) insertion/deletion. Keep dummy head/tail nodes to simplify edge cases.",
                        solution: {
                            python: `class Node:
            def __init__(self, key=0, val=0):
                self.key = key
                self.val = val
                self.prev = None
                self.next = None

        class LRUCache:
            def __init__(self, capacity):
                self.capacity = capacity
                self.cache = {}
                
                # Dummy head and tail
                self.head = Node()
                self.tail = Node()
                self.head.next = self.tail
                self.tail.prev = self.head
            
            def _add_node(self, node):
                # Add node right after head
                node.prev = self.head
                node.next = self.head.next
                
                self.head.next.prev = node
                self.head.next = node
            
            def _remove_node(self, node):
                # Remove an existing node
                node.prev.next = node.next
                node.next.prev = node.prev
            
            def _move_to_head(self, node):
                self._remove_node(node)
                self._add_node(node)
            
            def _pop_tail(self):
                last_node = self.tail.prev
                self._remove_node(last_node)
                return last_node
            
            def get(self, key):
                if key in self.cache:
                    node = self.cache[key]
                    self._move_to_head(node)
                    return node.val
                return -1
            
            def put(self, key, value):
                if key in self.cache:
                    node = self.cache[key]
                    node.val = value
                    self._move_to_head(node)
                else:
                    node = Node(key, value)
                    if len(self.cache) >= self.capacity:
                        tail = self._pop_tail()
                        del self.cache[tail.key]
                    
                    self.cache[key] = node
                    self._add_node(node)`,
                            javascript: `class Node {
            constructor(key = 0, val = 0) {
                this.key = key;
                this.val = val;
                this.prev = null;
                this.next = null;
            }
        }

        class LRUCache {
            constructor(capacity) {
                this.capacity = capacity;
                this.cache = new Map();
                
                // Dummy head and tail
                this.head = new Node();
                this.tail = new Node();
                this.head.next = this.tail;
                this.tail.prev = this.head;
            }
            
            _addNode(node) {
                // Add node right after head
                node.prev = this.head;
                node.next = this.head.next;
                
                this.head.next.prev = node;
                this.head.next = node;
            }
            
            _removeNode(node) {
                // Remove an existing node
                node.prev.next = node.next;
                node.next.prev = node.prev;
            }
            
            _moveToHead(node) {
                this._removeNode(node);
                this._addNode(node);
            }
            
            _popTail() {
                const lastNode = this.tail.prev;
                this._removeNode(lastNode);
                return lastNode;
            }
            
            get(key) {
                if (this.cache.has(key)) {
                    const node = this.cache.get(key);
                    this._moveToHead(node);
                    return node.val;
                }
                return -1;
            }
            
            put(key, value) {
                if (this.cache.has(key)) {
                    const node = this.cache.get(key);
                    node.val = value;
                    this._moveToHead(node);
                } else {
                    const node = new Node(key, value);
                    
                    if (this.cache.size >= this.capacity) {
                        const tail = this._popTail();
                        this.cache.delete(tail.key);
                    }
                    
                    this.cache.set(key, node);
                    this._addNode(node);
                }
            }
        }`
                        }
                    },
                    {
                        id: 7,
                        title: "Word Ladder Chain",
                        difficulty: "expert",
                        description: "Find shortest transformation sequence from beginWord to endWord, changing one letter at a time. Use BFS for shortest path.",
                        python: `def ladder_length(begin_word, end_word, word_list):
            # Your solution here
            # Return minimum transformations needed, 0 if impossible
            pass

        # Test case:
        # begin_word = "hit", end_word = "cog"
        # word_list = ["hot","dot","dog","lot","log","cog"]
        # Expected: 5 (hit -> hot -> dot -> dog -> cog)`,
                        javascript: `function ladderLength(beginWord, endWord, wordList) {
            // Your solution here
            // Return minimum transformations needed, 0 if impossible
        }

        // Test case:
        // beginWord = "hit", endWord = "cog"
        // wordList = ["hot","dot","dog","lot","log","cog"]
        // Expected: 5 (hit -> hot -> dot -> dog -> cog)`,
                        hint: "Use BFS since we want shortest path. For each word, try changing each character and see if result is in word list. Use set for O(1) lookups.",
                        solution: {
                            python: `from collections import deque

        def ladder_length(begin_word, end_word, word_list):
            if end_word not in word_list:
                return 0
            
            word_set = set(word_list)
            queue = deque([(begin_word, 1)])
            visited = {begin_word}
            
            while queue:
                word, length = queue.popleft()
                
                if word == end_word:
                    return length
                
                for i in range(len(word)):
                    for c in 'abcdefghijklmnopqrstuvwxyz':
                        next_word = word[:i] + c + word[i+1:]
                        
                        if next_word in word_set and next_word not in visited:
                            visited.add(next_word)
                            queue.append((next_word, length + 1))
            
            return 0`,
                            javascript: `function ladderLength(beginWord, endWord, wordList) {
            const wordSet = new Set(wordList);
            if (!wordSet.has(endWord)) return 0;
            
            const queue = [[beginWord, 1]];
            const visited = new Set([beginWord]);
            
            while (queue.length) {
                const [word, length] = queue.shift();
                
                if (word === endWord) return length;
                
                for (let i = 0; i < word.length; i++) {
                    for (let c = 97; c <= 122; c++) { // a-z
                        const nextWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);
                        
                        if (wordSet.has(nextWord) && !visited.has(nextWord)) {
                            visited.add(nextWord);
                            queue.push([nextWord, length + 1]);
                        }
                    }
                }
            }
            
            return 0;
        }`
                        }
                    },
                    {
                        id: 8,
                        title: "Serialize & Deserialize Binary Tree",
                        difficulty: "expert",
                        description: "Design algorithm to serialize binary tree to string and deserialize back. Handle null nodes. Use preorder traversal approach.",
                        python: `class TreeNode:
            def __init__(self, val=0, left=None, right=None):
                self.val = val
                self.left = left
                self.right = right

        def serialize(root):
            # Your solution here
            # Return string representation
            pass

        def deserialize(data):
            # Your solution here  
            # Return TreeNode root from string
            pass

        # Test: root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))
        # serialize(root) ‚Üí "1,2,None,None,3,4,None,None,5,None,None"`,
                        javascript: `class TreeNode {
            constructor(val = 0, left = null, right = null) {
                this.val = val;
                this.left = left;
                this.right = right;
            }
        }

        function serialize(root) {
            // Your solution here
            // Return string representation
        }

        function deserialize(data) {
            // Your solution here
            // Return TreeNode root from string  
        }

        // Test: root = new TreeNode(1, new TreeNode(2), new TreeNode(3, new TreeNode(4), new TreeNode(5)));
        // serialize(root); // "1,2,null,null,3,4,null,null,5,null,null"`,
                        hint: "Use preorder traversal for serialization. For deserialization, use same order with an index/iterator to track position in serialized string.",
                        solution: {
                            python: `def serialize(root):
            def helper(node):
                if not node:
                    return "None,"
                return str(node.val) + "," + helper(node.left) + helper(node.right)
            
            return helper(root)

        def deserialize(data):
            def helper():
                nonlocal index
                if index >= len(values) or values[index] == "None":
                    index += 1
                    return None
                
                node = TreeNode(int(values[index]))
                index += 1
                node.left = helper()
                node.right = helper()
                return node
            
            values = data.split(",")
            index = 0
            return helper()`,
                            javascript: `function serialize(root) {
            function helper(node) {
                if (!node) return "null,";
                return node.val + "," + helper(node.left) + helper(node.right);
            }
            
            return helper(root);
        }

        function deserialize(data) {
            const values = data.split(",");
            let index = 0;
            
            function helper() {
                if (index >= values.length || values[index] === "null") {
                    index++;
                    return null;
                }
                
                const node = new TreeNode(parseInt(values[index]));
                index++;
                node.left = helper();
                node.right = helper();
                return node;
            }
            
            return helper();
        }`
                        }
                    }
                ];

                let completedChallenges = new Set();
                let currentFilter = 'all';
                
                // Load progress from localStorage if available
                function loadProgress() {
                    try {
                        const saved = localStorage.getItem('codingProgress');
                        if (saved) {
                            completedChallenges = new Set(JSON.parse(saved));
                        }
                    } catch (e) {
                        // Handle gracefully if localStorage isn't available
                        completedChallenges = new Set();
                    }
                }
                
                // Save progress
                function saveProgress() {
                    try {
                        localStorage.setItem('codingProgress', JSON.stringify([...completedChallenges]));
                    } catch (e) {
                        // Handle gracefully if localStorage isn't available
                    }
                }
                
                function updateProgress() {
                    const progress = completedChallenges.size;
                    const total = challenges.length;
                    const percentage = (progress / total) * 100;
                    
                    document.getElementById('progressFill').style.width = `${percentage}%`;
                    document.getElementById('progressText').textContent = `${progress}/${total}`;
                }
                
                function showAll() {
                    currentFilter = 'all';
                    updateActiveButton();
                    renderChallenges();
                }
                
                function filterDifficulty(difficulty) {
                    currentFilter = difficulty;
                    updateActiveButton();
                    renderChallenges();
                }
                
                function updateActiveButton() {
                    document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
                    if (currentFilter === 'all') {
                        document.querySelector('.btn').classList.add('active');
                    } else {
                        document.querySelector(`[onclick="filterDifficulty('${currentFilter}')"]`).classList.add('active');
                    }
                }
                
                function resetProgress() {
                    if (confirm('Are you sure you want to reset your progress?')) {
                        completedChallenges.clear();
                        saveProgress();
                        updateProgress();
                        renderChallenges();
                    }
                }
                
                function toggleHint(id) {
                    const hintEl = document.getElementById(`hint-${id}`);
                    if (hintEl.style.display === 'none' || !hintEl.style.display) {
                        hintEl.style.display = 'block';
                        document.querySelector(`[onclick="toggleHint(${id})"]`).textContent = 'Hide Hint';
                    } else {
                        hintEl.style.display = 'none';
                        document.querySelector(`[onclick="toggleHint(${id})"]`).textContent = 'Show Hint';
                    }
                }
                
                function toggleSolution(id) {
                    const solutionEl = document.getElementById(`solution-${id}`);
                    if (solutionEl.style.display === 'none' || !solutionEl.style.display) {
                        solutionEl.style.display = 'block';
                        document.querySelector(`[onclick="toggleSolution(${id})"]`).textContent = 'Hide Solution';
                        markCompleted(id);
                    } else {
                        solutionEl.style.display = 'none';
                        document.querySelector(`[onclick="toggleSolution(${id})"]`).textContent = 'Show Solution';
                    }
                }
                
                function markCompleted(id) {
                    completedChallenges.add(id);
                    saveProgress();
                    updateProgress();
                    
                    // Add visual feedback
                    const card = document.querySelector(`[data-challenge-id="${id}"]`);
                    if (card && !card.classList.contains('completed')) {
                        card.classList.add('completed');
                        const title = card.querySelector('.challenge-title');
                        title.innerHTML = title.innerHTML + ' ‚úÖ';
                    }
                }
                
                function renderChallenges() {
                    const container = document.getElementById('challenges');
                    const filteredChallenges = currentFilter === 'all' ? 
                        challenges : challenges.filter(c => c.difficulty === currentFilter);
                    
                    container.innerHTML = filteredChallenges.map(challenge => `
                        <div class="challenge-card ${completedChallenges.has(challenge.id) ? 'completed' : ''}" 
                            data-challenge-id="${challenge.id}">
                            <div class="challenge-header">
                                <div class="challenge-title">
                                    ${challenge.title} ${completedChallenges.has(challenge.id) ? '‚úÖ' : ''}
                                </div>
                                <div class="difficulty ${challenge.difficulty}">${challenge.difficulty}</div>
                            </div>
                            
                            <div class="challenge-description">
                                ${challenge.description}
                            </div>
                            
                            <div class="code-section">
                                <div class="code-block">
                                    <h4>üêç Python</h4>
                                    <pre><code>${challenge.python}</code></pre>
                                </div>
                                <div class="code-block">
                                    <h4>‚ö° JavaScript</h4>
                                    <pre><code>${challenge.javascript}</code></pre>
                                </div>
                            </div>
                            
                            <div class="action-buttons">
                                <button class="action-btn hint-btn" onclick="toggleHint(${challenge.id})">
                                    üí° Show Hint
                                </button>
                                <button class="action-btn solution-btn" onclick="toggleSolution(${challenge.id})">
                                    üîç Show Solution
                                </button>
                            </div>
                            
                            <div class="hint" id="hint-${challenge.id}" style="display: none;">
                                <strong>üí° Hint:</strong> ${challenge.hint}
                            </div>
                            
                            <div class="solution" id="solution-${challenge.id}" style="display: none;">
                                <strong>üîç Solution:</strong>
                                <div class="code-section" style="margin-top: 15px;">
                                    <div class="code-block">
                                        <h4>üêç Python Solution</h4>
                                        <pre><code>${challenge.solution.python}</code></pre>
                                    </div>
                                    <div class="code-block">
                                        <h4>‚ö° JavaScript Solution</h4>
                                        <pre><code>${challenge.solution.javascript}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
                
                // Add some CSS for completed challenges
                const style = document.createElement('style');
                style.textContent = `
                    .challenge-card.completed {
                        border-left: 5px solid #4ecdc4;
                    }
                    
                    .challenge-card.completed .challenge-title {
                        color: #2d5a2d;
                    }
                `;
                document.head.appendChild(style);
                
                // Initialize
                loadProgress();
                updateProgress();
                renderChallenges();
    </script>
</body>
</html>






